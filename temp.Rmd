```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, interval = .2, eval = FALSE, fig.asp = 0.618, fig.width = 6, fig.align = 'center')
```
## Ggplot Tutorial - Part 3: Top 50 Ggplot2 Visualizations - The Master List

> What type of visualization to use for what sort of problem? This matters whenever the results of data analysis needs to be presented. This article provides guidelines to help you choose the right type of chart for your specific objectives. So when someone sees the plot, they instantly get it.

This is part 3 of a three part tutorial on ggplot2, an aesthetically pleasing (and very popular) graphics framework in R. This tutorial is primarily geared towards those having some basic knowledge of the R programming language and want to make complex and nice looking charts with R ggplot. 

 * [Part 1: Introduction to Ggplot](ggplot2-r-Tutorial-Part1.html), covers the basic knowledge about constructing simple ggplots and modifying the components and aesthetics.
 
 * [Part 2: Customizing the Look and Feel](ggplot2-r-Tutorial-Part2.html), is about more advanced customizations like manipulating legend, annotations, multiplots with faceting and custom layouts
 
 * [Part 3: Top 50 Ggplot2 Visualizations - The Master List](ggplot2-r-Tutorial-Part3.html), applies what was learnt in part 1 and 2 to construct other types of ggplots such as bar charts, boxplots etc.


### <a name="top"></a>Top 50 Ggplot2 Visualizations - The Master List

An effective chart is one that:

 - Conveys the right information without distorting facts.
 - Is simple but elegant. It should not force you to think much in order to get it.
 - Aesthetics supports information rather that overshadow it.
 - Is not overloaded with information.


1. [Correlation](ggplot2-r-Tutorial-Part3.html#1. Correlation)
    * [Scatterplot](ggplot2-r-Tutorial-Part3.html#Scatterplot)
    * [Scatterplot With Encircling](#Scatterplot With Encircling)
    * [Jitter Plot](ggplot2-r-Tutorial-Part3.html#Jitter Plot)
    * [Counts Chart](ggplot2-r-Tutorial-Part3.html#Counts Chart)
    * [Bubble Plot](ggplot2-r-Tutorial-Part3.html#Bubble Plot)
    * [Animated Bubble Plot](ggplot2-r-Tutorial-Part3.html#Animated Bubble Plot)
    * [Marginal Histogram / Boxplot](ggplot2-r-Tutorial-Part3.html#Marginal Histogram / Boxplot)
    * [Correlogram](ggplot2-r-Tutorial-Part3.html#Correlogram)
  
2. [Deviation](ggplot2-r-Tutorial-Part3.html#2. Deviation)
    * [Diverging Bars](ggplot2-r-Tutorial-Part3.html#Diverging Bars)
    * [Diverging Lollipop Chart](ggplot2-r-Tutorial-Part3.html#Diverging Lollipop Chart)
    * [Diverging Dot Plot](ggplot2-r-Tutorial-Part3.html#Diverging Dot Plot)
    * [Area Chart](ggplot2-r-Tutorial-Part3.html#Area Chart)
    
3. [Ranking](ggplot2-r-Tutorial-Part3.html#3. Ranking)
    * [Ordered Bar Chart](ggplot2-r-Tutorial-Part3.html#Ordered Bar Chart)
    * [Lollipop Chart](ggplot2-r-Tutorial-Part3.html#Lollipop Chart)
    * [Dot Plot](ggplot2-r-Tutorial-Part3.html#Dot Plot)
    * [Slope Chart](ggplot2-r-Tutorial-Part3.html#Slope Chart)
    * [Dumbbell Plot](ggplot2-r-Tutorial-Part3.html#Dumbbell Plot)
  
4. [Distribution](ggplot2-r-Tutorial-Part3.html#4. Distribution)
    * [Histogram](ggplot2-r-Tutorial-Part3.html#Histogram)
    * [Density Plot](ggplot2-r-Tutorial-Part3.html#Density Plot)
    * [Box Plot](ggplot2-r-Tutorial-Part3.html#Box Plot)
    * [Dot + Box Plot](ggplot2-r-Tutorial-Part3.html#Dot + Box Plot)
    * [Tufte Boxplot](ggplot2-r-Tutorial-Part3.html#Tufte Boxplot)
    * [Violin Plot](ggplot2-r-Tutorial-Part3.html#Violin Plot)
    * [Population Pyramid](ggplot2-r-Tutorial-Part3.html#Population Pyramid)
    
5. [Composition](ggplot2-r-Tutorial-Part3.html#5. Composition)
    * [Waffle Chart](#Waffle Chart)
    * [Pie Chart](#Pie Chart)
    * [Treemap](ggplot2-r-Tutorial-Part3.html#Treemap)
    * [Bar Chart](#Bar Chart)
    
6. [Change](ggplot2-r-Tutorial-Part3.html#6. Change)
    * [Time Series Plots](#Time Series Plots)
    * [Stacked Area Chart](#Stacked Area Chart)
    * [Calendar Heat Map](#Calendar Heat Map)
    * [Slope Chart](#Slope Chart)
    * [Seasonal Plot](#Seasonal Plot)
    
7. [Groups](ggplot2-r-Tutorial-Part3.html#7. Groups)
    * [Dendrogram](#Hierarchical Dendrogram)
    * [Clusters](ggplot2-r-Tutorial-Part3.html#Clusters)

8. [Spatial](ggplot2-r-Tutorial-Part3.html#8. Spatial)
    * [Open Street Map](#Open Street Map)
    * [Google Road Map](#Google Road Map)
    * [Google Hybrid Map](#Google Hybrid Map)

## 1. Correlation

### <a name="Scatterplot"></a>Scatterplot

The most frequently used plot for data analysis is undoubtedly the scatterplot. Whenever you want to understand the nature of relationship between two variables, invariably the first choice is the scatterplot.

```{r}
# load package and data
theme_set(theme_bw())  # pre-set the bw theme.
options(scipen=999)  # turn-off scientific notation like 1e+48
library(ggplot2)
data("midwest", package = "ggplot2")
# midwest <- read.csv("http://goo.gl/G1K41K")  # bkup data source

# Scatterplot
gg <- ggplot(midwest, aes(x=area, y=poptotal)) + 
  geom_point(aes(col=state, size=popdensity)) + 
  geom_smooth(method="loess", se=F) + xlim(c(0, 0.1)) + ylim(c(0, 500000)) + 
  labs(subtitle="Area Vs Population", y="Population", x="Area", title="Scatterplot", caption = "Source: midwest")

plot(gg)
```

![Ggplot Scatterplot](screenshots/ggplot_masterlist_1.png)

<a href="#top">[Back to Top]</a>

When presenting the results, sometimes I would encirlce certain points or regions in the chart so as to draw the attention to those particular cases.  But how to make a curve that goes around the points/regions of interest? 

This can be conveniently done using the `geom_encircle()` in `ggalt` package. Just set the `data` to a new dataframe that contains only the points (rows) or interest.  You can `expand` the curve so as to pass just outside the points. The `color` and `size` (thickness) of the curve can be modified as well. See below example.

```{r}
# install 'ggalt' pkg
# devtools::install_github("hrbrmstr/ggalt")
options(scipen = 999)
library(ggalt)
midwest_select <- midwest[midwest$poptotal > 350000 & midwest$poptotal <= 500000 & 
                     midwest$area > 0.01 & midwest$area < 0.1, ]

# Plot
ggplot(midwest, aes(x=area, y=poptotal)) + 
  geom_point(aes(col=state, size=popdensity)) +   # draw points
  geom_smooth(method="loess", se=F) + xlim(c(0, 0.1)) + ylim(c(0, 500000)) +   # draw smoothing line
  geom_encircle(aes(x=area, y=poptotal), data=midwest_select, color="red", size=2, expand=0.08) +   # draw circle
  labs(subtitle="Area Vs Population", y="Population", x="Area", 
       title="Scatterplot + Encircle", caption="Source: midwest")
```

<a name="Scatterplot With Encircling"></a>
![Ggplot Scatterplot With Encircling](screenshots/ggplot_masterlist_2.png)
<a href="#top">[Back to Top]</a>

### <a name="Jitter Plot"></a>Jitter Plot 
Let's look at new example of scatterplot. But this time, I will use the `mpg` dataset to plot city mileage (`cty`) vs highway mileage (`hwy`).

```{r}
# load package and data
library(ggplot2)
data(mpg, package="ggplot2") # alternate source: "http://goo.gl/uEeRGu")
theme_set(theme_bw())  # pre-set the bw theme.

g <- ggplot(mpg, aes(cty, hwy))

# Scatterplot
g + geom_point() + geom_smooth(method="lm", se=F) +
  labs(subtitle="mpg: city vs highway mileage", y="hwy", x="cty", 
       title="Scatterplot with overlapping points", 
       caption="Source: midwest")
```
![Ggplot Scatterplot With Hidden Data points](screenshots/ggplot_masterlist_3.png)
What we have here is a scatterplot of city and highway mileage in `mpg` dataset. We have seen a similar scatterplot and this looks neat and gives a clear idea of how the city mileage (`cty`) and highway mileage (`hwy`) are well correlated.

But, this innocent looking plot is _hiding_ something. Can you find out? 

```{r}
dim(mpg)
```

The original data has 234 data points but the chart seems to display fewer points. What has happened? This is because there are many overlapping points appearing as a single dot. The fact that both `cty` and `hwy` are integers in the source dataset made it all the more convenient to hide this detail. So just be extra careful the next time you make scatterplot with integers.

So how to handle this? There are few options. We can make a jitter plot with `jitter_geom()`. As the name suggests, the overlapping points are randomly jittered around its original position based on a threshold controlled by the `width` argument.
```{r}
# load package and data
library(ggplot2)
data(mpg, package="ggplot2")
# mpg <- read.csv("http://goo.gl/uEeRGu")

# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
g <- ggplot(mpg, aes(cty, hwy))
g + geom_jitter(width = .5, size=1) +
  labs(subtitle="mpg: city vs highway mileage", y="hwy", x="cty", 
       title="Jittered Points")
```
![Ggplot Jitter Plot](screenshots/ggplot_masterlist_4.png)
More points are revealed now. More the `width`, more the points are moved around from their original position.

<a href="#top">[Back to Top]</a>

### <a name="Counts Chart"></a>Counts chart
The second option is to use a counts chart. Where ever there more points overlap, the size of the circle gets bigger. I like this one.
```{r}
# load package and data
library(ggplot2)
data(mpg, package="ggplot2")
# mpg <- read.csv("http://goo.gl/uEeRGu")

# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
g <- ggplot(mpg, aes(cty, hwy))
g + geom_count(col="tomato3", show.legend=F) +
  labs(subtitle="mpg: city vs highway mileage", y="hwy", x="cty", 
       title="Counts Plot")
```
![Ggplot Counts Plot](screenshots/ggplot_masterlist_5.png)

<a href="#top">[Back to Top]</a>

### <a name="Bubble Plot"></a>Bubble plot
While scatterplot lets you compare the relationship between 2 continuous variables, bubble chart serves well if you want to understand underlying relationship within groups based on another categorical variable (by changing the color) and another continuous variable (by changing the size of points). In simpler words, bubble charts are more suitable if you have 4-Dimensional data where two of them are numeric (X and Y) and one other categorial (color) and another numeric variable(size).

```{r}
# load package and data
library(ggplot2)
data(mpg, package="ggplot2")
# mpg <- read.csv("http://goo.gl/uEeRGu")

mpg_select <- mpg[mpg$manufacturer %in% c("audi", "ford", "honda", "hyundai"), ]

# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
g <- ggplot(mpg_select, aes(displ, cty)) + labs(subtitle="mpg: Displacement vs City Mileage", 
                                                title="Bubble chart")

g + geom_jitter(aes(col=manufacturer, size=hwy)) + geom_smooth(aes(col=manufacturer), method="lm", se=F)
```
![Ggplot Bubble Plot](screenshots/ggplot_masterlist_6.png)

The bubble chart clearly distinguishes the range of `displ` between the manufacturers and how the slope of lines-of-bestfit varies, providing a better visual comparison between the groups.

<a href="#top">[Back to Top]</a>

### <a name="Animated Bubble Plot"></a>Animated Bubble chart
An animated bubbel chart can be implemented using the `gganimate` package. It is same as a bubble chart, but, you have to show how the values change over a fifth dimension (typically time).

```{r, interval = .2}
# Source: https://github.com/dgrtwo/gganimate
# install.packages("cowplot")  # a gganimate dependency
# devtools::install_github("dgrtwo/gganimate")
library(gganimate)
library(ggplot2)
library(gapminder)
theme_set(theme_bw())  # pre-set the bw theme.

g <- ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, frame = year)) +
  geom_point() +
  geom_smooth(aes(group = year), method = "lm", show.legend = FALSE) +
  facet_wrap(~continent, scales = "free") +
  scale_x_log10()  # convert to log scale

gganimate(g, interval=0.2)
```

![Ggplot Animated Bubble Plot](screenshots/ggplot_masterlist_7.gif)

<a href="#top">[Back to Top]</a>

### <a name="Marginal Histogram / Boxplot"></a>Marginal Histogram / Boxplot

If you want to show the relationship as well as the distribution of the variable, use the marginal histogram. It has a histogram of the X and Y variables at the margins of the scatterplot. This can be implemented using the `ggMarginal()` function from the '`ggExtra`' package. Apart from a histogram, you could choose to draw a `boxplot` or `density` plot by setting the `type` option.

```{r}
# load package and data
library(ggplot2)
library(ggExtra)
data(mpg, package="ggplot2")
# mpg <- read.csv("http://goo.gl/uEeRGu")

# Scatterplot
theme_set(theme_bw())  # pre-set the bw theme.
mpg_select <- mpg[mpg$hwy >= 35 & mpg$cty > 27, ]
g <- ggplot(mpg, aes(cty, hwy)) + geom_count() + 
                                  geom_smooth(method="lm", se=F)

ggMarginal(g, type = "histogram", fill="transparent")
ggMarginal(g, type = "boxplot", fill="transparent")
# ggMarginal(g, type = "density", fill="transparent")
```
![Ggplot Marginal Histogram](screenshots/ggplot_masterlist_8_1.png)
<br>
<br>
![Ggplot Marginal Histogram](screenshots/ggplot_masterlist_8_2.png)

<a href="#top">[Back to Top]</a>

### <a name="Correlogram"></a>Correlogram
```{r}
# devtools::install_github("kassambara/ggcorrplot")
library(ggplot2)
library(ggcorrplot)

# Correlation matrix
data(mtcars)
corr <- round(cor(mtcars), 1)

# Plot
ggcorrplot(corr, hc.order = TRUE, 
           type = "lower", 
           lab = TRUE, 
           lab_size = 3, 
           method="circle", 
           colors = c("tomato2", "white", "springgreen3"), 
           title="Correlogram of mtcars", 
           ggtheme=theme_bw)
```
![Ggplot Correlogram](screenshots/ggplot_masterlist_9.png)

<a href="#top">[Back to Top]</a>

## 2. Deviation 
Compare variation in _values_ between small number of categories with respect to a fixed reference. (diverging bar, spine chart, area chart)

### <a name="Diverging Bars"></a>Diverging bars
A bar chart that can handle both negative and positive values. By default, geom_bar() has the `stat` set to `count`. That means, when you provide just a continuous X variable (an no Y variable), it tries to make a histogram out of the data. 

In order to make a barchart create bars instead of histogram, you need to set `stat=identity` and provide both `x` and `y` inside `aes()` where, `x` is either `character` or `factor` and `y` is numeric.
```{r}
library(ggplot2)
theme_set(theme_bw())  

# Data Prep
data("mtcars")  # load data
mtcars$`car name` <- rownames(mtcars)  # create new column for car names
mtcars$mpg_z <- round((mtcars$mpg - mean(mtcars$mpg))/sd(mtcars$mpg), 2)  # compute normalized mpg
mtcars$mpg_type <- ifelse(mtcars$mpg_z < 0, "below", "above")  # above / below avg flag
mtcars <- mtcars[order(mtcars$mpg_z), ]  # sort
mtcars$`car name` <- factor(mtcars$`car name`, levels = mtcars$`car name`)  # convert to factor to retain sorted order in plot.

# Diverging Barcharts
ggplot(mtcars, aes(x=`car name`, y=mpg_z, label=mpg_z)) + 
  geom_bar(stat='identity', aes(fill=mpg_type), width=.5)  +
  scale_fill_manual(name="Mileage", 
                    labels = c("Above Average", "Below Average"), 
                    values = c("above"="#00ba38", "below"="#f8766d")) + 
  labs(subtitle="Normalised mileage from 'mtcars'", title= "Diverging Bars") + 
  coord_flip()
```
![Ggplot Diverging Bars](screenshots/ggplot_masterlist_10.png)

<a href="#top">[Back to Top]</a>

### <a name="Diverging Lollipop Chart"></a>Diverging Lollipop Chart
Lollipop chart conveys the same information as bar chart and diverging bar. Except that it looks more modern. Let's draw a lollipop using the same data I prepared in the previous example of diverging bars.
```{r}
library(ggplot2)
theme_set(theme_bw())

ggplot(mtcars, aes(x=`car name`, y=mpg_z, label=mpg_z)) + 
  geom_point(stat='identity', fill="black", size=6)  +
  geom_segment(aes(y = 0, x = `car name`, yend = mpg_z, xend = `car name`), color = "black") +
  geom_text(color="white", size=2) +
  labs(title="Diverging Lollipop Chart", 
       subtitle="Normalized mileage from 'mtcars': Lollipop") + 
  ylim(-2.5, 2.5) +
  coord_flip()
```
![Ggplot Lollipop Plot](screenshots/ggplot_masterlist_11.png)

<a href="#top">[Back to Top]</a>

### <a name="Diverging Dot Plot"></a>Diverging Dot Plot
Dot plot conveys similar information. Below example uses the same data prepared in the diverging bars example.
```{r}
library(ggplot2)
theme_set(theme_bw())

# Plot
ggplot(mtcars, aes(x=`car name`, y=mpg_z, label=mpg_z)) + 
  geom_point(stat='identity', aes(col=mpg_type), size=6)  +
  scale_color_manual(name="Mileage", 
                     labels = c("Above Average", "Below Average"), 
                     values = c("above"="#00ba38", "below"="#f8766d")) + 
  geom_text(color="white", size=2) +
  labs(title="Diverging Dot Plot", 
       subtitle="Normalized mileage from 'mtcars': Dotplot") + 
  ylim(-2.5, 2.5) +
  coord_flip()
```
![Ggplot Dotplot](screenshots/ggplot_masterlist_12.png)

<a href="#top">[Back to Top]</a>

### <a name="Area Chart"></a>Area Chart
How an individual stock performed compared to a baseline

```{r}
library(ggplot2)
library(quantmod)
data("economics")
head(economics$pce)
economics$returns_perc <- c(0, diff(economics$psavert)/economics$psavert[-length(economics$psavert)])

# create break points and labels for axis ticks
brks <- economics$date[seq(1, length(economics$date), 12)]
lbls <- lubridate::year(economics$date[seq(1, length(economics$date), 12)])

# plot
ggplot(economics[1:100, ], aes(date, returns_perc)) + geom_area() + scale_x_date(breaks=brks, labels=lbls) + 
  theme(axis.text.x = element_text(angle=90)) + 
  labs(title="Area Chart", subtitle = "Perc Returns for Personal Savings", y="% Returns for Personal savings", caption="Source: economics")
```
![Ggplot Area Chart](screenshots/ggplot_masterlist_13.png)

<a href="#top">[Back to Top]</a>

## 3. Ranking
Used to compare the position or performance of multiple items with respect to each other. Actual values matters somewhat less than the ranking.

### <a name="Ordered Bar Chart"></a>Ordered Bar Chart
If you want to plot the mean city mileage of each manufacturer, we might first aggregate the data and sort it before you draw the plot. Just sorting the dataframe by the variable of interest isn't enough to order the bar chart. In order for the barchart to retain the order of the rows, the X axis variable (car names in this case) has to be converted into a factor.
```{r}
# Prepare data: group mean city mileage by manufacturer.
cty_mpg <- aggregate(mpg$cty, by=list(mpg$manufacturer), FUN=mean)  # aggregate
colnames(cty_mpg) <- c("make", "mileage")  # change column names
cty_mpg <- cty_mpg[order(cty_mpg$mileage), ]  # sort
cty_mpg$make <- factor(cty_mpg$make, levels = cty_mpg$make)  # to retain the order in plot.
head(cty_mpg, 4)
#>          make  mileage
#> 9     lincoln 11.33333
#> 8  land rover 11.50000
#> 3       dodge 13.13514
#> 10    mercury 13.25000

```

The data is ready, let's plot.
```{r}
library(ggplot2)
theme_set(theme_bw())

# Draw plot
ggplot(cty_mpg, aes(x=make, y=mileage)) + 
  geom_bar(stat="identity", width=.5, fill="tomato3") + 
  labs(title="Ordered Bar Chart", subtitle="Make Vs Avg. Mileage", caption="source: mpg") + 
  theme(axis.text.x = element_text(angle=65, vjust=0.6))
```
![Ggplot Ordered Barchart](screenshots/ggplot_masterlist_14.png)

<a href="#top">[Back to Top]</a>

### <a name="Lollipop Chart"></a>Lollipop Chart 
Lollipop charts conveys the same information as in barcharts. By reducing the thick bars to thin lines, it reduces the clutter and lays more emphasis on the value. Looks nice and modern.

```{r}
library(ggplot2)
theme_set(theme_bw())

# Plot
ggplot(cty_mpg, aes(x=make, y=mileage)) + 
  geom_point(size=3) + 
  geom_segment(aes(x=make, xend=make, y=0, yend=mileage)) + 
  labs(title="Lollipop Chart", subtitle="Make Vs Avg. Mileage", caption="source: mpg") + 
  theme(axis.text.x = element_text(angle=65, vjust=0.6))
```
![Ggplot Lollipop Barchart](screenshots/ggplot_masterlist_15.png)

<a href="#top">[Back to Top]</a>

### <a name="Dot Plot"></a>Dot Plot
Dot plots are very similar to lollipops, but without the line and is flipped to horizontal position. It emphasizes more on the rank ordering of items with respect to actual values and how far apart are the entities with respect to each other.
```{r}
library(ggplot2)
library(scales)
theme_set(theme_classic())

# Plot
ggplot(cty_mpg, aes(x=make, y=mileage)) + 
  geom_point(col="tomato2", size=3) +   # Draw points
  geom_segment(aes(x=make, xend=make, y=min(mileage), yend=max(mileage)), linetype="dashed", size=0.1) +   # Draw dashed lines
  labs(title="Dot Plot", subtitle="Make Vs Avg. Mileage", caption="source: mpg") +  
  coord_flip()
```
![Ggplot Dot Plot](screenshots/ggplot_masterlist_16.png)

<a href="#top">[Back to Top]</a>

### <a name="Slope Chart"></a>Slope Chart
```{r}
library(ggplot2)
library(scales)
theme_set(theme_classic())

# prep data
df <- read.csv("https://raw.githubusercontent.com/selva86/datasets/master/gdppercap.csv")
colnames(df) <- c("continent", "1952", "1957")
left_label <- paste(df$continent, round(df$`1952`),sep=", ")
right_label <- paste(df$continent, round(df$`1957`),sep=", ")
df$class <- ifelse((df$`1957` - df$`1952`) < 0, "red", "green")

# Plot
p <- ggplot(df) + geom_segment(aes(x=1, xend=2, y=`1952`, yend=`1957`, col=class), size=.75, show.legend=F) + 
                  geom_vline(xintercept=1, linetype="dashed", size=.1) + 
                  geom_vline(xintercept=2, linetype="dashed", size=.1) +
                  scale_color_manual(labels = c("Up", "Down"), 
                                     values = c("green"="#00ba38", "red"="#f8766d")) +  # color of lines
                  labs(x="", y="Mean GdpPerCap") +  # Axis labels
                  xlim(.5, 2.5) + ylim(0,(1.1*(max(df$`1952`, df$`1957`))))  # X and Y axis limits

# Add texts
p <- p + geom_text(label=left_label, y=df$`1952`, x=rep(1, NROW(df)), hjust=1.1, size=3.5)
p <- p + geom_text(label=right_label, y=df$`1957`, x=rep(2, NROW(df)), hjust=-0.1, size=3.5)
p <- p + geom_text(label="Time 1", x=1, y=1.1*(max(df$`1952`, df$`1957`)), hjust=1.2, size=5)  # title
p <- p + geom_text(label="Time 2", x=2, y=1.1*(max(df$`1952`, df$`1957`)), hjust=-0.1, size=5)  # title

# Minify theme
p + theme(panel.background = element_blank(), 
           panel.grid = element_blank(),
           axis.ticks = element_blank(),
           axis.text.x = element_blank(),
           panel.border = element_blank(),
           plot.margin = unit(c(1,2,1,2), "cm"))
```
![Ggplot Slope Chart](screenshots/ggplot_masterlist_17.png)

<a href="#top">[Back to Top]</a>

### <a name="Dumbbell Plot"></a>Dumbbell Plot
Dumbbell charts are a great tool if you wish to:
 - Visualise relative positions (like growth and decline) between two points in time (1)
 - Compare distance between two categories. (2)

In order to get the correct ordering of the dumbells, the Y varible should be a factor and the levels of the factor variable should be in the same order as it should appear in the plot.
```{r}
# devtools::install_github("hrbrmstr/ggalt")
library(ggplot2)
library(ggalt)
theme_set(theme_classic())

health <- read.csv("https://raw.githubusercontent.com/selva86/datasets/master/health.csv")
health$Area <- factor(health$Area, levels=as.character(health$Area))  # for right ordering of the dumbells

# health$Area <- factor(health$Area)
gg <- ggplot(health, aes(x=pct_2013, xend=pct_2014, y=Area, group=Area)) + 
        geom_dumbbell(color="#a3c4dc", size=0.75, point.colour.l="#0e668b") + 
        scale_x_continuous(label=percent) + 
        labs(x=NULL, y=NULL, title="Dumbbell Chart", subtitle="Pct Change: 2013 vs 2014", caption="Source: https://github.com/hrbrmstr/ggalt") +
        theme(plot.title = element_text(hjust=0.5, face="bold"),
              plot.background=element_rect(fill="#f7f7f7"),
              panel.background=element_rect(fill="#f7f7f7"),
              panel.grid.minor=element_blank(),
              panel.grid.major.y=element_blank(),
              panel.grid.major.x=element_line(),
              axis.ticks=element_blank(),
              legend.position="top",
              panel.border=element_blank())
plot(gg)
```
![Ggplot Dumbbell Chart](screenshots/ggplot_masterlist_18.png)

<a href="#top">[Back to Top]</a>

## 4. Distribution
When you have lots and lots of datapoints and want to study where and how the data points are distributed.
https://github.com/hrbrmstr/ggalt

### <a name="Histogram"></a>Histogram 
Now, Let's move on to barchart. By default, if only one variable is supplied, the `geom_bar()` tries to calculate the count. In order for it to behave like a bar chart, the `stat=identity` option has to be set and `x` and `y` values must be provided.


#### Histogram on a continuous variable
Histogram on a continuous variable can be accomplished using either `geom_bar()` or `geom_histogram()`. When using `geom_histogram()`, you can control the number of bars using the `bins` option. Else, you can set the range covered by each bin using `binwidth`. The value of `binwidth` is on the same scale as the continuous variable on which histogram is built.
Since, `geom_histogram` gives facility to control both number of `bins` as well as `binwidth`, it is the preferred option to create histogram on continuous variables.

```{r}
library(ggplot2)
theme_set(theme_classic())

# Histogram on a Continuous (Numeric) Variable
g <- ggplot(mpg, aes(displ)) + scale_fill_brewer(palette = "Spectral")

g + geom_histogram(aes(fill=class), binwidth = .1, col="black", size=.1) +  # change binwidth
  labs(title="Histogram with Auto Binning", subtitle="Engine Displacement across Vehicle Classes")   

g + geom_histogram(aes(fill=class), bins=5, col="black", size=.1) +   # change number of bins
  labs(title="Histogram with Fixed Bins", subtitle="Engine Displacement across Vehicle Classes") 
```
![Ggplot Histogram on Numeric Variable](screenshots/ggplot_masterlist_19.png)
![Ggplot Histogram with 5 Bins - Spectral](screenshots/ggplot_masterlist_20.png)

<a href="#top">[Back to Top]</a>

#### Histogram on a categorical variable
Histogram on a categorical variable would result in a frequency chart showing bars for each category. By adjusting `width`, you can adjust the thickness of the bars.
```{r}
library(ggplot2)
theme_set(theme_classic())

# Histogram on a Categorical variable
g <- ggplot(mpg, aes(manufacturer))
g + geom_bar(aes(fill=class), width = 0.5) + theme(axis.text.x = element_text(angle=65, vjust=0.6)) + 
  labs(title="Histogram on Categorical Variable", subtitle="Manufacturer across Vehicle Classes") 
```
![Ggplot Histogram on Categorical Variable](screenshots/ggplot_masterlist_22.png)

So according to this dataset, only chevrolet manufactures 2seaters. Jeep, landrover, lincoln and mercury makes only SUVs. Also, Toyota seems to have the largest mix, with 4 classes of cars. Can you think of a couple of such observations?

<a href="#top">[Back to Top]</a>

### <a name="Density Plot"></a>Density plot
```{r}
library(ggplot2)
theme_set(theme_classic())

# Plot
g <- ggplot(mpg, aes(cty))
g + geom_density(aes(fill=factor(cyl))) + labs(title="Density plot", 
                                               subtitle="City Mileage Grouped by Number of cylinders",
                                               caption="Source: mpg",
                                               x="City Mileage",
                                               fill="# Cylinders")
```
![Ggplot Density Plot](screenshots/ggplot_masterlist_23.png)

<a href="#top">[Back to Top]</a>

### <a name="Box Plot"></a>Box Plot
Boxplot shows the distributions within multiple groups, additionally showing the median, range and outliers if any. The dark line inside the box represents the median. The top of box is 75%ile and bottom of box is 25%ile. The end points of the lines (aka whiskers) is at a distance of 1.5*IQR, where IQR or Inter Quartile Range is the distance between 25th and 75th percentiles. The points outside the whiskers are marked as dots and are normally considered as extreme points.

Setting `varwidth=T` adjusts the width of the boxes to be proportional to the number of observation it contains.
```{r}
library(ggplot2)
theme_set(theme_classic())

# Plot
g <- ggplot(mpg, aes(class, cty))
g + geom_boxplot(varwidth=T, fill="plum") + labs(title="Box plot", 
                                                 subtitle="City Mileage grouped by Class of vehicle",
                                                 caption="Source: mpg",
                                                 x="Class of Vehicle",
                                                 y="City Mileage")
```
![Ggplot BoxPlot](screenshots/ggplot_masterlist_24.png)

```{r}
library(ggthemes)
g <- ggplot(mpg, aes(class, cty))
g + geom_boxplot(aes(fill=factor(cyl))) + 
  theme(axis.text.x = element_text(angle=65, vjust=0.6)) + 
  labs(title="Box plot", 
       subtitle="City Mileage grouped by Class of vehicle",
       caption="Source: mpg",
       x="Class of Vehicle",
       y="City Mileage")
```
![Ggplot Grouped BoxPlot](screenshots/ggplot_masterlist_25.png)

<a href="#top">[Back to Top]</a>

### <a name="Dot + Box Plot"></a>Dot + Box Plot 
The dotplot can provide more clear information in the form of summary statistics by each group. The dots are stacked such that each dot represents one observation. So, in below chart, the number of dots for a given manufacturer will match the number of rows of that manufacturer in source data.

```{r}
library(ggplot2)
theme_set(theme_bw())

# plot
g <- ggplot(mpg, aes(manufacturer, cty))
g + geom_boxplot() + 
  geom_dotplot(binaxis='y', stackdir='center', dotsize = .5, fill="red") +
  theme(axis.text.x = element_text(angle=65, vjust=0.6)) + 
  labs(title="Box plot + Dot plot", 
       subtitle="City Mileage vs Class: Each dot represents 1 row in source data",
       caption="Source: mpg",
       x="Class of Vehicle",
       y="City Mileage")
```
![Ggplot Box and DotPlot](screenshots/ggplot_masterlist_26.png)

<a href="#top">[Back to Top]</a>

### <a name="Tufte Boxplot"></a>Tufte Boxplot
Tufte boxplot, provided by `ggthemes` package is inspired by the works of Edward Tufte. Tufte's Boxplot is just a box plot made minimal and visually appealing.
```{r}
library(ggthemes)
library(ggplot2)
theme_set(theme_tufte())  # from ggthemes

# plot
g <- ggplot(mpg, aes(manufacturer, cty))
g + geom_tufteboxplot() + 
      theme(axis.text.x = element_text(angle=65, vjust=0.6)) + 
      labs(title="Tufte Styled Boxplot", 
           subtitle="City Mileage grouped by Class of vehicle",
           caption="Source: mpg",
           x="Class of Vehicle",
           y="City Mileage")

```
![Ggplot Tufte Boxplot](screenshots/ggplot_masterlist_27.png)

<a href="#top">[Back to Top]</a>

### <a name="Violin Plot"></a>Violin Plot
A violin plot is similar to boxplot but shows the density within groups. Not much info provided as in boxplots. It can be drawn using `geom_violin()`.
```{r}
library(ggplot2)
theme_set(theme_bw())

# plot
g <- ggplot(mpg, aes(class, cty))
g + geom_violin() + 
  labs(title="Violin plot", 
       subtitle="City Mileage vs Class of vehicle",
       caption="Source: mpg",
       x="Class of Vehicle",
       y="City Mileage")
```
![Ggplot Violin Plot](screenshots/ggplot_masterlist_28.png)

<a href="#top">[Back to Top]</a>

### <a name="Population Pyramid"></a>Population Pyramid
```{r}
library(ggplot2)
library(ggthemes)
options(scipen = 999)  # turns of scientific notations like 1e+40

# Read data
email_campaign_funnel <- read.csv("https://raw.githubusercontent.com/selva86/datasets/master/email_campaign_funnel.csv")

# X Axis Breaks and Labels 
brks <- seq(-15000000, 15000000, 5000000)
lbls = paste0(as.character(c(seq(15, 0, -5), seq(5, 15, 5))), "m")

# Plot
ggplot(email_campaign_funnel, aes(x = Stage, y = Users, fill = Gender)) +   # Fill column
                              geom_bar(stat = "identity", width = .6) +   # draw the bars
                              scale_y_continuous(breaks = brks,   # Breaks
                                                 labels = lbls) + # Labels
                              coord_flip() +  # Flip axes
                              labs(title="Email Campaign Funnel") +
                              theme_tufte() +  # Tufte theme from ggfortify
                              theme(plot.title = element_text(hjust = .5), 
                                    axis.ticks = element_blank()) +   # Centre plot title
                              scale_fill_brewer(palette = "Dark2")  # Color palette
```

![Population Pyramid With Ggplot](screenshots/ggplot_masterlist_29.png)

<a href="#top">[Back to Top]</a>

## 5. Composition

### <a name="Waffle Chart"></a>Waffle Chart
```{r}
var <- mpg$class  # the categorical data 

## Prep data (nothing to change here)
nrows <- 10
df <- expand.grid(y = 1:nrows, x = 1:nrows)
categ_table <- round(table(var) * ((nrows*nrows)/(length(var))))
categ_table
#>   2seater    compact    midsize    minivan     pickup subcompact        suv 
#>         2         20         18          5         14         15         26 

df$category <- factor(rep(names(categ_table), categ_table))  
# NOTE: if sum(categ_table) is not 100 (i.e. nrows^2), it will need adjustment to make the sum to 100.

## Plot
ggplot(df, aes(x = x, y = y, fill = category)) + 
        geom_tile(color = "black", size = 0.5) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0), trans = 'reverse') +
        scale_fill_brewer(palette = "Set3") +
        labs(title="Waffle Chart", subtitle="'Class' of vehicles",
             caption="Source: mpg") + 
        theme(panel.border = element_rect(size = 2),
              plot.title = element_text(size = rel(1.2)),
              axis.text = element_blank(),
              axis.title = element_blank(),
              axis.ticks = element_blank(),
              legend.title = element_blank(),
              legend.position = "right")
```
![Waffle Chart With Ggplot](screenshots/ggplot_masterlist_30.png)

<a href="#top">[Back to Top]</a>

### <a name="Pie Chart"></a>Pie Chart
```{r}
library(ggplot2)
theme_set(theme_classic())

# Source: Frequency table
df <- as.data.frame(table(mpg$class))
colnames(df) <- c("class", "freq")
pie <- ggplot(df, aes(x = "", y=freq, fill = factor(class))) + 
  geom_bar(width = 1, stat = "identity") +
  theme(axis.line = element_blank(), plot.title = element_text(hjust=0.5)) + 
  labs(fill="class", x=NULL, y=NULL, title="Pie Chart of class", caption="Source: mpg")

pie + coord_polar(theta = "y", start=0)

# Source: Categorical variable.
# mpg$class
pie <- ggplot(mpg, aes(x = "", fill = factor(class))) + 
  geom_bar(width = 1) +
  theme(axis.line = element_blank(), plot.title = element_text(hjust=0.5)) + 
  labs(fill="class", x=NULL, y=NULL, title="Pie Chart of class", caption="Source: mpg")
  
pie + coord_polar(theta = "y", start=0)
```
![Pie Chart With Ggplot](screenshots/ggplot_masterlist_31.png)

```{r}
# http://www.r-graph-gallery.com/128-ring-or-donut-plot/
```

<a href="#top">[Back to Top]</a>

### <a name="Treemap"></a>Treemap
Treemap: treemapping is a method for displaying hierarchical data by using nested rectangles.

```{r}
library(ggplot2) 
library(treemapify)
proglangs <- read.csv("https://raw.githubusercontent.com/selva86/datasets/master/proglanguages.csv")

# plot
treeMapCoordinates <- treemapify(proglangs,
                                 area = "value",
                                 fill = "parent",
                                 label = "id",
                                 group = "parent")

treeMapPlot <- ggplotify(treeMapCoordinates) + 
                  scale_x_continuous(expand = c(0, 0)) +
                  scale_y_continuous(expand = c(0, 0)) +
                  scale_fill_brewer(palette = "Dark2")

print(treeMapPlot)
```
![Treemap With Ggplot](screenshots/ggplot_masterlist_32.png)

<a href="#top">[Back to Top]</a>

### <a name="Bar Chart"></a>Bar Chart
A bar chart can be drawn from a categorical column variable or from a separate frequency table. By adjusting `width`, you can adjust the thickness of the bars. If your data source is a frequency table, that is, if you don't want ggplot to compute the counts, you need to set the `stat=identity` inside the `geom_bar()`.

```{r}
# prep frequency table
freqtable <- table(mpg$manufacturer)
df <- as.data.frame.table(freqtable)
head(df)
#>          Var1 Freq
#> 1        audi   18
#> 2   chevrolet   19
#> 3       dodge   37
#> 4        ford   25
#> 5       honda    9
#> 6     hyundai   14
```

```{r}
# plot
library(ggplot2)
theme_set(theme_classic())

# Plot
g <- ggplot(df, aes(Var1, Freq))
g + geom_bar(stat="identity", width = 0.5, fill="tomato2") + 
      labs(title="Bar Chart", subtitle="Manufacturer of vehicles", caption="Source: Frequency of Manufacturers from 'mpg' dataset") +
      theme(axis.text.x = element_text(angle=65, vjust=0.6))
```
![Bar Chart With Ggplot](screenshots/ggplot_masterlist_33.png)

It can be computed directly from a column variable as well. In this case, only X is provided and `stat=identity` is _not_ set.
```{r}
# From on a categorical column variable
g <- ggplot(mpg, aes(manufacturer))
g + geom_bar(aes(fill=class), width = 0.5) + theme(axis.text.x = element_text(angle=65, vjust=0.6)) +
  labs(title="Categorywise Bar Chart", subtitle="Manufacturer of vehicles", caption="Source: Manufacturers from 'mpg' dataset")
```
![Bar Chart With Multiple Categories in Ggplot](screenshots/ggplot_masterlist_34.png)

So according to this dataset, only chevrolet manufactures 2seaters. Jeep, landrover, lincoln and mercury makes only SUVs. Also, Toyota seems to have the largest mix, with 4 classes of cars. Can you think of a couple of such observations?

<a href="#top">[Back to Top]</a>

## 6. Change
### <a name="Time Series Plots"></a>Time Series Plots
#### From a Time Series Object (`ts`)
The `ggfortify` package allows autoplot to automatically plot directly from a time series object (`ts`).
```{r}
## From Timeseries object (ts)
library(ggplot2)
library(ggfortify)
theme_set(theme_classic())

# Plot 
autoplot(AirPassengers) + labs(title="AirPassengers") + theme(plot.title = element_text(hjust=0.5))
```
![Time series in ggplot with ts object](screenshots/ggplot_masterlist_35.png)

#### From a Data Frame
##### Default X Axis Labels
```{r}
library(ggplot2)
theme_set(theme_classic())

# Allow Default X Axis Labels
ggplot(economics, aes(x=date)) + 
  geom_line(aes(y=returns_perc)) + 
  labs(title="Time Series Chart", 
       subtitle="Returns Percentage from 'Economics' Dataset", 
       caption="Source: Economics", 
       y="Returns %")
```
![Time series in ggplot from Dataframe](screenshots/ggplot_masterlist_36.png)

#### How to Format X Axis Labels for a _Monthly_ Time Series
```{r}
library(ggplot2)
library(lubridate)
theme_set(theme_bw())

economics_m <- economics[1:24, ]

# labels and breaks for X axis text
lbls <- paste0(month.abb[month(economics_m$date)], " ", lubridate::year(economics_m$date))
brks <- economics_m$date

# plot
ggplot(economics_m, aes(x=date)) + 
  geom_line(aes(y=returns_perc)) + 
  labs(title="Monthly Time Series", subtitle="Returns Percentage from Economics Dataset", caption="Source: Economics", y="Returns %") +  # title and caption
  scale_x_date(labels = lbls, breaks = brks) +  # change to monthly ticks and labels
  theme(axis.text.x = element_text(angle = 90, vjust=0.5),  # rotate x axis text
        panel.grid.minor = element_blank())  # turn off minor grid
```
![Monthly Time series in ggplot](screenshots/ggplot_masterlist_37.png)

<a href="#top">[Back to Top]</a>

#### How to Format X Axis Labels for a _Yearly_ Time Series
```{r}
library(ggplot2)
library(lubridate)
theme_set(theme_bw())

economics_y <- economics[1:90, ]

# labels and breaks for X axis text
brks <- economics_y$date[seq(1, length(economics_y$date), 12)]
lbls <- lubridate::year(brks)

# plot
ggplot(economics_y, aes(x=date)) + 
  geom_line(aes(y=returns_perc)) + 
  labs(title="Yearly Time Series", subtitle="Returns Percentage from Economics Dataset", caption="Source: Economics", y="Returns %") +  # title and caption
  scale_x_date(labels = lbls, breaks = brks) +  # change to monthly ticks and labels
  theme(axis.text.x = element_text(angle = 90, vjust=0.5),  # rotate x axis text
        panel.grid.minor = element_blank())  # turn off minor grid
```
![Yearly Time series in ggplot](screenshots/ggplot_masterlist_38.png)

<a href="#top">[Back to Top]</a>

#### Long Data Format: Multiple Time Series in Same Dataframe
```{r}
library(ggplot2)
library(lubridate)
theme_set(theme_bw())

df <- economics_long[economics_long$variable %in% c("psavert", "uempmed"), ]
df <- df[lubridate::year(df$date) %in% c(1967:1981), ]

# labels and breaks for X axis text
brks <- df$date[seq(1, length(df$date), 12)]
lbls <- lubridate::year(brks)

# plot
ggplot(df, aes(x=date)) + 
  geom_line(aes(y=value, col=variable)) + 
  labs(title="Time Series of Returns Percentage", 
       subtitle="Drawn from Long Data format", 
       caption="Source: Economics", 
       y="Returns %", 
       color=NULL) +  # title and caption
  scale_x_date(labels = lbls, breaks = brks) +  # change to monthly ticks and labels
  scale_color_manual(labels = c("psavert", "uempmed"), 
                     values = c("psavert"="#00ba38", "uempmed"="#f8766d")) +  # line color
  theme(axis.text.x = element_text(angle = 90, vjust=0.5, size = 8),  # rotate x axis text
        panel.grid.minor = element_blank())  # turn off minor grid
```
![Yearly Time series in ggplot from Long Data format](screenshots/ggplot_masterlist_39.png)

<a href="#top">[Back to Top]</a>

#### Wide Data Format: Multiple Time Series in Same Dataframe
```{r}
library(ggplot2)
library(lubridate)
theme_set(theme_bw())

df <- economics[, c("date", "psavert", "uempmed")]
df <- df[lubridate::year(df$date) %in% c(1967:1981), ]

# labels and breaks for X axis text
brks <- df$date[seq(1, length(df$date), 12)]
lbls <- lubridate::year(brks)

# plot
ggplot(df, aes(x=date)) + 
  geom_line(aes(y=psavert, col="psavert")) + 
  geom_line(aes(y=uempmed, col="uempmed")) + 
  labs(title="Time Series of Returns Percentage", 
       subtitle="Drawn From Wide Data format", 
       caption="Source: Economics", y="Returns %") +  # title and caption
  scale_x_date(labels = lbls, breaks = brks) +  # change to monthly ticks and labels
  scale_color_manual(name="", 
                     values = c("psavert"="#00ba38", "uempmed"="#f8766d")) +  # line color
  theme(panel.grid.minor = element_blank())  # turn off minor grid
```
![Time series in ggplot from Wide Data Format](screenshots/ggplot_masterlist_40.png)

<a href="#top">[Back to Top]</a>

### <a name="Stacked Area Chart"></a>Stacked Area Chart
Show how something changed over time along with the contributions from individual components. The caveat is: it is nice to look at but can easily become complicated and uninterprettable if there are too many components.

```{r}
library(ggplot2)
library(lubridate)
theme_set(theme_bw())

df <- economics[, c("date", "psavert", "uempmed")]
df <- df[lubridate::year(df$date) %in% c(1967:1981), ]

# labels and breaks for X axis text
brks <- df$date[seq(1, length(df$date), 12)]
lbls <- lubridate::year(brks)

# plot
ggplot(df, aes(x=date)) + 
  geom_area(aes(y=psavert, fill="psavert")) + 
  geom_area(aes(y=uempmed, fill="uempmed")) + 
  labs(title="Area Chart of Returns Percentage", 
       subtitle="From Wide Data format", 
       caption="Source: Economics", 
       y="Returns %") +  # title and caption
  scale_x_date(labels = lbls, breaks = brks) +  # change to monthly ticks and labels
  scale_fill_manual(name="", values = c("psavert"="#00ba38", "uempmed"="#f8766d")) +  # line color
  theme(panel.grid.minor = element_blank())  # turn off minor grid
```
![Stacked Area Chart in Ggplot](screenshots/ggplot_masterlist_41.png)

<a href="#top">[Back to Top]</a>

### <a name="Calendar Heatmap"></a>Calendar Heatmap
Calendar Heatmap: Shows variation visually over time rather than the actual value.

```{r}
# http://margintale.blogspot.in/2012/04/ggplot2-time-series-heatmaps.html
require(ggplot2)
require(plyr)
require(scales)
df <- read.csv("https://raw.githubusercontent.com/selva86/datasets/master/yahoo.csv")
df$date <- as.Date(df$date)  # format date
df <- df[df$year >= 2012, ]  # filter reqd years

# Create Month Week
df$yearmonth <- as.yearmon(df$date)
df$yearmonthf <- factor(df$yearmonth)
df <- ddply(df,.(yearmonthf), transform, monthweek=1+week-min(week))

# Plot
ggplot(df, aes(monthweek, weekdayf, fill = VIX.Close)) + 
  geom_tile(colour = "white") + 
  facet_grid(year~monthf) + 
  scale_fill_gradient(low="red", high="green") +
  labs(title = "Time-Series Calendar Heatmap", subtitle="Yahoo Cloing Price", fill="Close") +  xlab("Week of Month") + ylab("")
```
![Calendar Heatmap in Ggplot](screenshots/ggplot_masterlist_42.png)

<a href="#top">[Back to Top]</a>

### <a name="Slope Chart"></a>Slope Chart
```{r}
library(dplyr)
theme_set(theme_classic())
source_df <- read.csv("https://raw.githubusercontent.com/jkeirstead/r-slopegraph/master/cancer_survival_rates.csv")

# Define functions. Source: https://github.com/jkeirstead/r-slopegraph
tufte_sort <- function(df, x="year", y="value", group="group", method="tufte", min.space=0.05) {
    ## First rename the columns for consistency
    ids <- match(c(x, y, group), names(df))
    df <- df[,ids]
    names(df) <- c("x", "y", "group")

    ## Expand grid to ensure every combination has a defined value
    tmp <- expand.grid(x=unique(df$x), group=unique(df$group))
    tmp <- merge(df, tmp, all.y=TRUE)
    df <- mutate(tmp, y=ifelse(is.na(y), 0, y))
  
    ## Cast into a matrix shape and arrange by first column
    require(reshape2)
    tmp <- dcast(df, group ~ x, value.var="y")
    ord <- order(tmp[,2])
    tmp <- tmp[ord,]
    
    min.space <- min.space*diff(range(tmp[,-1]))
    yshift <- numeric(nrow(tmp))
    ## Start at "bottom" row
    ## Repeat for rest of the rows until you hit the top
    for (i in 2:nrow(tmp)) {
        ## Shift subsequent row up by equal space so gap between
        ## two entries is >= minimum
        mat <- as.matrix(tmp[(i-1):i, -1])
        d.min <- min(diff(mat))
        yshift[i] <- ifelse(d.min < min.space, min.space - d.min, 0)
    }

    
    tmp <- cbind(tmp, yshift=cumsum(yshift))

    scale <- 1
    tmp <- melt(tmp, id=c("group", "yshift"), variable.name="x", value.name="y")
    ## Store these gaps in a separate variable so that they can be scaled ypos = a*yshift + y

    tmp <- transform(tmp, ypos=y + scale*yshift)
    return(tmp)
   
}

plot_slopegraph <- function(df) {
    ylabs <- subset(df, x==head(x,1))$group
    yvals <- subset(df, x==head(x,1))$ypos
    fontSize <- 3
    gg <- ggplot(df,aes(x=x,y=ypos)) +
        geom_line(aes(group=group),colour="grey80") +
        geom_point(colour="white",size=8) +
        geom_text(aes(label=y), size=fontSize, family="American Typewriter") +
        scale_y_continuous(name="", breaks=yvals, labels=ylabs)
    return(gg)
}    

## Prepare data    
df <- tufte_sort(source_df, x="year", y="value", group="group", method="tufte", min.space=0.05)
df <- transform(df, x=factor(x, levels=c(5,10,15,20), labels=c("5 years","10 years","15 years","20 years")), 
                y=round(y))

## Plot
plot_slopegraph(df) + labs(title="Estimates of % survival rates") + theme(axis.title=element_blank(), 
                                                                          axis.ticks = element_blank(),
                                                                          plot.title = element_text(hjust=0.5,
                                                                                                    family = "American Typewriter",
                                                                                                    face="bold"),
                                                                          axis.text = element_text(family = "American Typewriter",
                                                                                                   face="bold"))
```
![Slopechart in Ggplot](screenshots/ggplot_masterlist_43.png)

<a href="#top">[Back to Top]</a>

### <a name="Seasonal Plot"></a>Seasonal Plot 
If you are working with a time series object of class `ts` or `xts`, you can view the seasonal fluctuations through a seasonal plot drawn using `forecast::ggseasonplot`. Below is an example using the native `nottem` time series.
```{r}
library(ggplot2)
library(forecast)
theme_set(theme_classic())

# Subset data
nottem_small <- window(nottem, start=c(1920, 1), end=c(1925, 12))  # subset a smaller timewindow

# Plot
ggseasonplot(AirPassengers) + labs(title="Seasonal plot: International Airline Passengers")
ggseasonplot(nottem_small) + labs(title="Seasonal plot: Air temperatures at Nottingham Castle")
```
![Seasonal Plot in Ggplot](screenshots/ggplot_masterlist_45.png)
<br>
![Seasonal Plot in Ggplot](screenshots/ggplot_masterlist_46.png)

<a href="#top">[Back to Top]</a>

## 7. Groups
### <a name="Hierarchical Dendrogram"></a>Hierarchical Dendrogram
```{r}
# install.packages("ggdendro")
library(ggplot2)
library(ggdendro)
theme_set(theme_bw())

hc <- hclust(dist(USArrests), "ave")  # hierarchical clustering

# plot
ggdendrogram(hc, rotate = TRUE, size = 2)
```
![Hierarchical Dendrogram in Ggplot](screenshots/ggplot_masterlist_48.png)

<a href="#top">[Back to Top]</a>

### <a name="Clusters"></a>Clusters
```{r}
# devtools::install_github("hrbrmstr/ggalt")
library(ggplot2)
library(ggalt)
library(ggfortify)
theme_set(theme_classic())

# Compute data with principal components ------------------
df <- iris[c(1, 2, 3, 4)]
pca_mod <- prcomp(df)  # compute principal components

# Data frame of principal components ----------------------
df_pc <- data.frame(pca_mod$x, Species=iris$Species)  # dataframe of principal components
df_pc_vir <- df_pc[df_pc$Species == "virginica", ]  # df for 'virginica'
df_pc_set <- df_pc[df_pc$Species == "setosa", ]  # df for 'setosa'
df_pc_ver <- df_pc[df_pc$Species == "versicolor", ]  # df for 'versicolor'
 
# Plot ----------------------------------------------------
ggplot(df_pc, aes(PC1, PC2, col=Species)) + 
  geom_point(aes(shape=Species), size=2) +   # draw points
  labs(title="Iris Clustering", 
       subtitle="With principal components PC1 and PC2 as X and Y axis",
       caption="Source: Iris") + 
  coord_cartesian(xlim = 1.2 * c(min(df_pc$PC1), max(df_pc$PC1)), 
                  ylim = 1.2 * c(min(df_pc$PC2), max(df_pc$PC2))) +   # change axis limits
  geom_encircle(data = df_pc_vir, aes(x=PC1, y=PC2)) +   # draw circles
  geom_encircle(data = df_pc_set, aes(x=PC1, y=PC2)) + 
  geom_encircle(data = df_pc_ver, aes(x=PC1, y=PC2))
```
![Clustering in Ggplot](screenshots/ggplot_masterlist_49.png)

<a href="#top">[Back to Top]</a>

## 8. Spatial
```{r}
# Better install the dev versions ----------
# devtools::install_github("dkahle/ggmap")
# devtools::install_github("hrbrmstr/ggalt")

# load packages
library(ggplot2)
library(ggmap)
library(ggalt)

# Get Chennai's Coordinates --------------------------------
chennai <-  geocode("Chennai")  # get longitude and latitude

# Get the Map ----------------------------------------------
# Google Satellite Map
chennai_ggl_sat_map <- qmap("chennai", zoom=12, source = "google", maptype="satellite")  

# Google Road Map
chennai_ggl_road_map <- qmap("chennai", zoom=12, source = "google", maptype="roadmap")  

# Google Hybrid Map
chennai_ggl_hybrid_map <- qmap("chennai", zoom=12, source = "google", maptype="hybrid")  

# Open Street Map
chennai_osm_map <- qmap("chennai", zoom=12, source = "osm")   

# Get Coordinates for Chennai's Places ---------------------
chennai_places <- c("Kolathur",
                    "Washermanpet",
                    "Royapettah",
                    "Adyar",
                    "Guindy")

places_loc <- geocode(chennai_places)  # get longitudes and latitudes


# Plot Open Street Map -------------------------------------
chennai_osm_map + geom_point(aes(x=lon, y=lat),
                             data = places_loc, 
                             alpha = 0.7, 
                             size = 7, 
                             color = "tomato") + 
                  geom_encircle(aes(x=lon, y=lat),
                                data = places_loc, size = 2, color = "blue")

# Plot Google Road Map -------------------------------------
chennai_ggl_road_map + geom_point(aes(x=lon, y=lat),
                                  data = places_loc, 
                                  alpha = 0.7, 
                                  size = 7, 
                                  color = "tomato") + 
                       geom_encircle(aes(x=lon, y=lat),
                                     data = places_loc, size = 2, color = "blue")

# Google Hybrid Map ----------------------------------------
chennai_ggl_hybrid_map + geom_point(aes(x=lon, y=lat),
                                     data = places_loc, 
                                     alpha = 0.7, 
                                     size = 7, 
                                     color = "tomato") + 
                          geom_encircle(aes(x=lon, y=lat),
                                        data = places_loc, size = 2, color = "blue")

```

### Open Street Map <a name="Open Street Map"></a>

![Spatial Map in Ggplot2 Ggmap](screenshots/ggplot_masterlist_50.png)

<a href="#top">[Back to Top]</a>

### Google Road Map <a name="Google Road Map"></a>

![Google Road Map in Ggplot2 Ggmap](screenshots/ggplot_masterlist_51.png)

<a href="#top">[Back to Top]</a>

### Google Hybrid Map <a name="Google Hybrid Map"></a>

![Google Hybrid Map in Ggplot2 Ggmap](screenshots/ggplot_masterlist_52.png)

<a href="#top">[Back to Top]</a>

___________________________________________________

Have a suggestion or found a bug? Notify [here.](https://docs.google.com/forms/d/e/1FAIpQLSeIJmlvwe562R7JVpi5J2ydLyhk5-7OrGRMFGYrMJvjPal8eA/viewform)

_**Editors Note:** The [mastering R programming](packtpub.com/big-data-and-business-intelligence/mastering-r-programming-video) video course has a dedicated section for ggplot2 where the concepts are demonstrated in detail. Additionally it includes solving real coding challenges at the end of every video lesson._

