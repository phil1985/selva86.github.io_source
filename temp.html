<blockquote>
<p>R provides a number of convenient facilities for parallel computing. The following method shows you how to setup and run a parallel process on your current multi-core device, without need for additional hardware.</p>
</blockquote>
<h2>Setting up for parallelization</h2>
<p>The number of parallel processes you can run simultaneously depends on the number of cores in your machine. If you are on a Windows PC, open ‘Task Manager’ =&gt; ‘Performance’ tab, and count the number of boxes below “CPU Usage History”. That is the maximum number of parallel processes you can run in your computer. You can practically use all of them for R computations, however, it is a good idea to leave out a core or two for background system processes. Here is how you can set up your R session for parallel processing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Registering cores for parallel process</span>
<span class="kw">library</span>(doSNOW)
cl &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(<span class="dv">4</span>, <span class="dt">type=</span><span class="st">&quot;SOCK&quot;</span>) <span class="co"># 4 – number of cores</span>
<span class="kw">registerDoSNOW</span>(cl) <span class="co"># Register back end Cores for Parallel Computing</span></code></pre></div>
<h2>Running the parallel process</h2>
<p>Once the cores are set up to run computations in parallel, the ‘foreach’ loop (from foreach package) can run your functions in parallel by opening as many parallel R session as the number of cores you have registered. The difference between a regular for-loop and for-each loop is, the for-loop runs serially, i.e. your loop processes one value of loop-counter (i) at a time. While in for-each, the arguments you supply to the loop-counter (‘i’ in this case) will be run simultaneously at {number_of_cores_initialised} number of processes at a time. After running the functions defined inside the loop, it combines all the returned values based on the function supplied to the ‘.combine‘ argument.</p>
<h2>Parallel processing: some simple examples</h2>
<p>In the examples below, replace %dopar% with %do% to make it run as a non-parallel process.</p>
<h4>Example 1</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(foreach)
<span class="kw">foreach</span>(<span class="dt">i =</span> <span class="dv">1</span>:<span class="dv">28</span>) %dopar%<span class="st"> </span>{<span class="kw">sqrt</span>(i)} <span class="co"># example 1</span></code></pre></div>
<h4>Example 2</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># returned output values of the parallel process are combined using &#39;c()&#39; function</span>
<span class="kw">foreach</span>(<span class="dt">i =</span> <span class="dv">1</span>:<span class="dv">28</span>,<span class="dt">.combine =</span> <span class="st">&quot;c&quot;</span>) %dopar%<span class="st"> </span>{<span class="kw">sqrt</span>(i)} <span class="co"># example 2</span></code></pre></div>
<h4>Example 3</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># returned output values of the parallel process are combined using &#39;cbind()&#39; function</span>
<span class="kw">foreach</span>(<span class="dt">i =</span> <span class="dv">1</span>:<span class="dv">28</span>,<span class="dt">.combine =</span> <span class="st">&quot;cbind&quot;</span>) %dopar%<span class="st"> </span>{letters[<span class="dv">1</span>:<span class="dv">4</span>]} <span class="co"># example 3 </span></code></pre></div>
<h4>Example 4</h4>
<p>You can also create your own combining function as you wish.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># combine using your custom defined function: &quot;myCustomFunc()&quot; and store in &#39;output&#39; variable</span>
output &lt;-<span class="st"> </span><span class="kw">foreach</span>(<span class="dt">i =</span> <span class="dv">1</span>:<span class="dv">28</span>, <span class="dt">.combine =</span> <span class="st">&quot;myCustomFunc&quot;</span>) %dopar%<span class="st"> </span>{
  <span class="kw">sqrt</span>(i)
}</code></pre></div>
<p><code>myCustomFunc</code> above is just a placeholder. ## Further Customizing for packages and output aggregation</p>
<p>You are nearly there, just a couple more things left. If you are using functions from packages loaded to your global R environment, they may not work inside the for-each loop, because, multiple R sessions are instantiated for each parallel process. So you need to define the packages you need inside the foreach loop in the .packages argument. Additionally, if you have a set of variables to iterate over in a separate R object (like a data frame), you can even pass it as a separate iterating variable (allRowIndices) in this case, in the foreach statement. Here is a sample of the code to show how it might look like.</p>
<h2>Structure of a typical parallel processing code</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">allRowIndices &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(inputData)) <span class="co"># assign row indices of inputData, that will be processed in parallel</span>

output &lt;-<span class="st"> </span><span class="kw">foreach</span> (<span class="dt">rowNum =</span> allRowIndices, <span class="dt">.combine =</span> rbind, <span class="dt">.packages =</span> <span class="kw">c</span>(<span class="st">&quot;caret&quot;</span>, <span class="st">&quot;ggplot2&quot;</span>, <span class="st">&quot;Hmisc&quot;</span>)) %dopar%<span class="st"> </span>{
  <span class="co"># code to process each rowNum goes within this block.</span>
  <span class="co"># &#39;n&#39; rows will be processed simultaneously, where &#39;n&#39; is number of registered cores.</span>
  <span class="co"># after processing all rows, the returned value is combined using the function defined in `.combine` argument `rbind` in this case. The output thus aggregated is stored in output variable.</span>
  <span class="co"># Finally, the packages required by functions in this block has to be mentioned within .packages argument.</span>
}
<span class="kw">stopCluster</span>(cl) <span class="co"># undo the parallel processing setup</span></code></pre></div>
<p>In the above code, the main component of parallelisation is the foreach loop and the three arguments that go along with it. The first argument (rownum) here is a row counter that iterates through all the rows in ‘allRowIndices’. The second one, ‘.combine’ is a function that will be used to aggregate the results of all computations from the rows. In this case, ‘rbind’ will be used to append the results in rows. Finally, the third one ‘.packages’, states which all packages will be needed for the functions used within the ‘foreach’ block. Note that, even if you have already included the packages before calling the ‘foreach’, you need to re-specify within this block, since, new R sessions will be opened for the parallel processing. With all these defined, the computations will be done in parallel based on the number of cores you had registered earlier and the results get combined and stored in <code>output</code>.</p>
<h2>A comparison between parallel and non-parallel process</h2>
<p>To demonstrate the processing times, a simple math operation is performed on each row of a 4-columned matrix created below. The time taken by a parallel vs non-parallel process is compared as the number of rows in inputData is gradually increased.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inputData &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>:<span class="dv">800000</span>, <span class="dt">ncol=</span><span class="dv">4</span>) <span class="co"># prepare input data</span>
<span class="kw">head</span>(inputData)
<span class="co">#&gt;      [,1]   [,2]   [,3]   [,4]</span>
<span class="co">#&gt; [1,]    1 200001 400001 600001</span>
<span class="co">#&gt; [2,]    2 200002 400002 600002</span>
<span class="co">#&gt; [3,]    3 200003 400003 600003</span>
<span class="co">#&gt; [4,]    4 200004 400004 600004</span>
<span class="co">#&gt; [5,]    5 200005 400005 600005</span>
<span class="co">#&gt; [6,]    6 200006 400006 600006</span>
<span class="co"># For each row of inputData, we&#39;ll compute the output as follows: </span>
row output =<span class="st"> </span>col1 *<span class="st"> </span>col2 +<span class="st"> </span>col3 /<span class="st"> </span>col4</code></pre></div>
<h3>1. Non-parallel version</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">output_serial &lt;-<span class="st"> </span><span class="kw">numeric</span>() <span class="co"># initialize output</span>
for (rowNum in <span class="kw">c</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(inputData))) {
  calculatedOutput &lt;-<span class="st"> </span>inputData[rowNum, <span class="dv">1</span>] *<span class="st"> </span>inputData[rowNum, <span class="dv">2</span>] +<span class="st"> </span>inputData[rowNum, <span class="dv">3</span>] /<span class="st"> </span>inputData[rowNum, <span class="dv">4</span>] <span class="co"># compute output</span>
  output_serial &lt;-<span class="st"> </span><span class="kw">c</span>(output_serial, calculatedOutput) <span class="co"># append to output variable</span>
}</code></pre></div>
<h3>2. Parallel version</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(doSNOW)
cl &lt;-<span class="st"> </span><span class="kw">makeCluster</span>(<span class="dv">4</span>, <span class="dt">type=</span><span class="st">&quot;SOCK&quot;</span>) <span class="co"># 4 – number of cores</span>
<span class="kw">registerDoSNOW</span>(cl) <span class="co"># Register Backend Cores for Parallel Computing</span>
allRowIndices &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>:<span class="kw">nrow</span>(inputData)) <span class="co"># row numbers of inputData, that will be processed in parallel</span>
output_parallel &lt;-<span class="st"> </span><span class="kw">foreach</span> (<span class="dt">rowNum =</span> allRowIndices, <span class="dt">.combine =</span> c) %dopar%<span class="st"> </span>{
  calculatedOutput &lt;-<span class="st"> </span>inputData[rowNum, <span class="dv">1</span>] *<span class="st"> </span>inputData[rowNum, <span class="dv">2</span>] +<span class="st"> </span>inputData[rowNum, <span class="dv">3</span>] /<span class="st"> </span>inputData[rowNum, <span class="dv">4</span>] <span class="co"># compute output</span>
  <span class="kw">return</span> (calculatedOutput)
}</code></pre></div>
